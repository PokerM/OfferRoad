# 设计模式之六大原则
1. [单一职责原则](https://blog.csdn.net/lovelion/article/details/7536542)
2. [开闭原则](http://blog.csdn.net/lovelion/article/details/7537584)
3. [里氏替换原则](http://blog.csdn.net/lovelion/article/details/7540445)
4. [依赖倒置原则](http://blog.csdn.net/lovelion/article/details/7562783)
5. [接口隔离原则](http://blog.csdn.net/lovelion/article/details/7562842)
6. [迪米特原则](http://blog.csdn.net/lovelion/article/details/7563445)

## 单一职责原则
单一职责原则(Single Responsiblility Priciple, SRP)：一个类或者方法只负责一个功能领域的相应职责。

There should never be more than one reason for a class to change.

单一职责原则是实现高内聚、低耦合的指导方针，需要发现类的不同职责，并将其分离。

单一职责原则好处：
- 复杂性降低
- 可读性提高
- 可维护性提高
- 变更引起的风险降低

## 开闭原则
开闭原则(Open-Closed Princeple, OCP)：一个软件应当对扩展开放，对修改关闭。即软件实体应尽量在不修改原有代码的情况下进行扩展。

抽象化是开闭原则的关键。

多态是开闭原则非常好的例子。若需要扩展功能，只需要添加一个派生类，并重写虚函数，那么可以在不修改原有代码的情况下，完成对功能的扩展。

## 里氏替换原则
里氏替换原则(Liskov Substitution Principle, LSP)：所有引用基类（父类）的地方必须能够透明地使用其子类的对象。

Functions that use pointers or references to base classes must be able to use objects of derived classes without knowing it.

在软件中，将一个基类替换成它的子类对象，程序将不会产生任何错误和异常。例如，我喜欢动物，那么我一定喜欢狗，因为狗是动物的子集；但是喜欢狗不一定喜欢动物。

里氏替换原则是实现开闭原则的重要方式之一。在程序中，尽量使用基类类型来对对象进行定义，而在运行时再确定其子类类型，用子类对象来替代父类对象。

## 依赖倒置原则
依赖倒置原则(Dependency Inversion Principle, DIP)：抽象不应该依赖于细节，细节应当依赖于抽象。

High level modules should not depend upon low level modules.Both should depend upon abstractions.Abstractions should not depend upon details.Details should depend upon abstractions.

依赖倒置原则要求我们在程序代码中传递参数时，尽量引用层次高的抽象层类。为了确保该原则的应用，一个具体类应当只实现接口或者抽象类中声明过的方法，而不要给出多余的方法，否则无法调用到子类中增加的新方法。

在实现依赖倒转原则时，我们需要针对抽象层编程，而将具体类的对象通过**依赖注入**(DependencyInjection, DI)的方式注入到其他对象中，**依赖注入是指当一个对象要与其他对象发生依赖关系时，通过抽象来注入所依赖的对象**。常用的注入方式有三种，分别是：**构造注入，设值注入（Setter注入）和接口注入**。
- 构造注入是指通过构造函数来传入具体类的对象
- 设值注入是指通过Setter方法来传入具体类的对象
- 接口注入是指通过在接口中声明的业务方法来传入具体类的对象

实践中遵循以下规则以实现该原则：
1. 每个类尽量都有接口或抽象类
2. 变量的表面类型尽量是接口或者抽象类
3. 任何类都不应该从具体类派生
4. 尽量不要覆盖基类的方法
5. 结合里氏替换原则使用

## 接口隔离原则
接口隔离原则(Interface Segregation Principle, ISP)：使用多个专门的接口，而不使用单一的总接口，即客户端不应该依赖那些它不需要的接口。

每一个接口应该承担一种相对独立的角色，不干不该干的事，该干的事都要干。

在使用接口隔离原则时，我们需要注意控制接口的粒度，接口不能太小，如果太小会导致系统中接口泛滥，不利于维护；接口也不能太大，太大的接口将违背接口隔离原则，灵活性较差，使用起来很不方便。一般而言，接口中仅包含为某一类用户定制的方法即可，不应该强迫客户依赖于那些它们不用的方法。

## 迪米特原则
迪米特法则(Law of Demeter, LoD，也称为最少知识原则)：一个软件实体应当尽可能少地与其他实体发生相互作用。

通俗地讲，一个类应该对自己需要耦合或调用的类知道得最少（类中的方法与变量尽可能为private）

迪米特法则可降低系统的耦合度，使得类与类之间保持松散的耦合关系

迪米特法则有几种定义形式，包括：不要和“陌生人”说话，只与你的直接朋友通信等。

对于一个对象，其朋友主要包括
- 当前对象本身
- 以参数形式传入到当前对象方法中的对象
- 当前对象的成员对象
- 若当前对象的成员对象是一个集合，那么集合中的元素也是朋友
- 当前对象所创建的对象

迪米特法则要求尽量减少对象之间的交互，若两个对象之间不必直接通信，那么这两个对象不应该直接发生任何直接的相互作用，如果其中一个对象需要调用另一个对象的某个方法，可以通过第三者转发这个调用。

通过引入一个合理的第三者来降低现有对象之间的耦合度

迪米特法则对类的低耦合提出了明确的要求，包含以下4层含义：
1. 只和朋友交流
2. 控制与朋友的距离（朋友中方法尽可能为private）
3. 是自己的就是自己的：如果一个方法放在本类中，即不增加类间关系，也对本类不产生负面影响，那就放置到本类中

