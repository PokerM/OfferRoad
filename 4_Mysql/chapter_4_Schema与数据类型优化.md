# 第4章 Schema与数据类型优化

## 4.1 选择优化的数据类型
数据类型选择原则：
- **更小**：应该尽量使用可以正确存储数据的最小数据类型
- **简单**：简单的数据类型的操作消耗时间更少。例如整型比字符操作代价低。例子：使用MySql内建类型而不是字符串来存储日期和时间，另一个是用整型存储IP地址。
- **避免NULL**：通常情况下最好指定列为NOT NULL。若查询中包含NULL的列，对于MySql来说都很难优化，因为NULL的列使得索引、索引统计和值比较都更复杂。

DATETIME：时间和日期，精确到秒。

TIMESTAMP：时间和日期，精确到秒。只占DATETIME一半的存储空间，并且会根据时区变化，具有特殊的自动更新能力，但其允许的时间范围要小得多。

### 4.1.1 整型
TINYINT SMALLINT MEDIUMINT INT BIGINT。分别占用8、16、24、32、64位存储空间。具有可选UNSIGNED属性。

选择的数据类型决定了MySql怎么在内存和磁盘中保存数据。然而在整数计算时一般使用64位的BIGINT。

MySql可以为整数类型指定宽度，例如INT(11)，但不会限制其范围，只是限制了显示字符的个数。

### 4.1.2 实数类型
实数是带有小数部分的数字。然而它们还可以用来存储比BIGINT还大的整数。

FLOAT和DOUBLE类型支持使用标准的浮点运算进行近似计算。DECIMAL类型用于存储精确的小数。DECIMAL类型支持精确计算。

浮点和DECIMAL类型都可以指定精度。DECIMAL可以指定小数点前后所允许的最大位数。

浮点类型在存储相同范围的值时，通常比DECIMAL使用更少的空间。MySql使用DOUBLE作为内部浮点计算的类型。

因为需要额外的空间和计算开销，所以应该只在对小数进行精确计算时才使用DECIMAL。在数据量比较大时，可以考虑使用BIGINT代替DECIMAL，将数据乘以相应的倍数即可。

### 4.1.3 字符串类型

**VARCHAR和CHAR类型**
- VARCHAR：变长字符串。在字符串长度变化大时比较合适。会使用额外的空间来保存长度信息。
- CHAR：定长字符串。根据定义的字符串长度来分配足够的空间。

与CHAR和VARCHAR类似的类型还有BINARY和VARBINARY，它们存储的是二进制字符串，二进制字符串存储的是字节码而不是字符。

**BLOB和TEXT类型**
 BLOB和TEXT都用来存储很大的数据而设计的字符串数据类型，分别采用二进制和字符方式存储。实际上它们分属于不同的家族：字符类型TINYTEXT，SMALLTEXT，TEXT，MEDIUMTEXT，LONGTEXT；对应的二进制类型为TINYBLOB，SMALLBLOB，BLOB，MEDIUMBLOB，LONGBLOB。

 与其他类型不同，MySql把每个BLOB和TEXT当做独立对象处理。

 MySql对于BLOB和TEXT进行排序时，只对每个列的最前max_sort_length字节进行排序。

 MySql不能对BLOB和TEXT全部字符串进行索引。

 **使用枚举（ENUM）代替字符串类型**
 使用枚举列代替常用的字符串类型。MySql在存储枚举时非常紧凑。

 ### 4.1.4 日期和时间类型
 **DATETIME**：可以保存1001年到9999年，精度为秒。它将日期和时间封装到格式为YYYYMMDDHHMMSS的战术中，与时区无关。使用8个字节的存储空间。

 **TIMESTAMP**：可以保存从1970年1月1日以来的秒数，和UNIX时间戳相同。只使用4个字节的存储空间，只能表示从1970年到2038年。与时区相关。

 一般来说，通常使用TIMESTAMP，因为它有更高的空间效率。需要更小粒度的时间，可以采用BIGINT类型存储微秒级别的时间戳或者DOUBLE类型存储秒之后的小数部分。

### 4.1.6 选择标识符
整数类型是最好的选择，因为它们很快，而且可以使用AUTO_INCREMENT。ENUM和SET类型不适用。字符串类型比较消耗空间，而且比数字类型慢。

## 4.2 MySql schema设计中的陷阱
**太多的列**
MySql的存储引擎API工作时需要在服务器层和存储引擎层之间通过行缓冲格式拷贝数据。太多的列会使得转换代价很高。

**太多的关联**
“实体-属性-值”（EAV）设计模式时一个常见的糟糕设计模式。MySql限制了每个关联操作最多只能有61张表。一般来说，如果希望查询执行得快速并且并发性好，单个查询最好在12个表以内做关联。

**全能枚举**
过度使用枚举

## 4.3 范式和反范式
在范式化的数据库中，每个事实数据会出现并只出现一次；而在反范式化的数据库中，信息时冗余的，可能存储在多个地方。

### 4.3.1 范式的优缺点
范式化优点：
- 范式化更新操作比反范式化快
- 当数据较好地范式化时，就只有很少或者没有重复数据，只需要修改更少的数据
- 范式化的表通常更小，可以更好地放到内存中，执行更快

范式化缺点：
通常需要关联。查询语句在符合范式化的schema上都可能需要至少一次关联，这不但代价昂贵，也可能使得索引策略无效。

### 4.3.2 反范式的优缺点
反范式的schema所有数据都在一个表中，可以避免关联。若没有关联表，则对于大部分查询最差的情况（即没有索引）是全表扫描。当数据比内存大时，这比关联快的多，因为避免了随机IO。

### 4.3.3 混用范式化和反范式化
最常见的反范式化数据的方法是复制或者缓存，在不同的表中存储相同的特定列。可以使用触发器更新缓存值。

## 4.4 缓存表和汇总表
有时提升性能最好的方法是在同一张表中保存衍生的冗余数据。

### 4.4.1 物化视图
物化视图是预先计算并且存储在磁盘上的表，通过各种策略更新和刷新。

### 4.4.2 计数器表
技巧：预先在表中增加100行数据，随机选择一行数据进行更新，要获得统计结构则将所有100行数据相加

## 4.6 总结
- 尽量避免过度设计
- 使用小而简单的合适数据类型
- 尽量使用相同的数据类型存储相似或相关的值
- 注意可变长字符串，其在临时表或者排序时，可能导致悲观地按最大长度分配内存
- 尽量使用整型定义标识列
- 避免使用MySql遗弃的特性
- 小心使用ENUM和SET
